               ::::::::   ::::::::  :::::::::  ::::::::::
              :+:    :+: :+:    :+: :+:    :+: :+:
              +:+        +:+        +:+    +:+ +:+
              +#++:++#++ +#++:++#++ +#+    +:+ +#++:++#
                     +#+        +#+ +#+    +#+ +#+
              #+#    #+# #+#    #+# #+#    #+# #+#
               ########   ########  #########  ##########

                The Small Scalable Disassembler Engine
Copyright (C) 2015, Constantine Shablya. See Copyright Notice in LICENSE.txt
                   http://github.com/notnanocat/ssde



 1 Что такое SSDE?
 2 "Зачем нужен SSDE, если дизассемблерные движки подобные HDE, diStorm,
  BeaEngine и т.д. уже существуют?" или "Преимущества SSDE"
  2.1 Производительность и бенчмарки
 3 Как использовать SSDE?
  3.1 Разные архитектуры
  3.2 Ошибки в декодировании инструкций
  3.3 Многопоточность
 4 Добавление поддержки новой архитектуры
 5 Сообщение об ошибке



1 Что такое SSDE?

  SSDE это маленький, масштабируемый дизассемблерный движок, предназначение
  которого заключается в анализе машинного кода и получения информации
  о инструкциях (их длинна, опкод, правильность и т.д.).

  SSDE довольно функционален, например: на нем можно построить полноценный
  дизассемблер, который мог бы выводить ассемблерный текст программы,
  полученный из машинного кода посредством SSDE. Масштабируемость SSDE
  позволяет проводить анализ, предположим, нескольких ветвлений кода
  одновременно при помощи многопоточности.

2. "Зачем нужен SSDE, если дизассемблерные движки подобные
  HDE, diStorm, BeaEngine и т.д. уже существуют?" или "преимущества SSDE"

  Мотивацией для написания SSDE мне послужило то, что существующие движки
  либо слишком большие и/или лицензируются под лицензией GNU GPL (такими
  есть: diStorm, BeaEngine), либо они были слишком старыми, а их
  разработкой и поддержкой никто не занимался (HDE). SSDE можно назвать
  более новым и современным аналогом HDE. Кроме того, планируется
  поддержка других архитектур процессоров (в ближайшее время: x86 64,
  ARM32). Также хотел бы добавить, что SSDE лицензируется под MIT
  лицензией, что дает Вам право использовать его в своих приватных и/или
  коммерческих проэктах без каких-либо ограничений и обязательств. Модули
  SSDE пишутся с расчетом на то, что они будут работать не зависимо от
  архитектуры и порядка байт процессора, ОС и т.д. Весь код SSDE написан
  на C++ с соблюдением стандарта C++11, весь public API документирован
  (смотри "ssde.hpp"), а реализация довольно чиста и сопровождаема.

  Главными преимуществами SSDE над другими движками являются:

    - модульность (используй только то, что нужно)
    - высокая производительность при анализе длинных последовательностей
        кода
    - небольшой размер
    - независим от архитектуры и порядка байт процессора, ОС
    - свободен в использовании


  Особенность модуля ssde_x86:

    - поддержка новых и не очень расширений
        AES, SHA, VMX
        MMX, 3DNow! (базовая), SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2
        прочие мелкие расширения (CPUID, ADX, RDSEED, RDRAND и т.д.)

2.1 Бенчмарки

  В настоящее время надлежащих бенчмарков проведено не было, однако, я
  провел микро бенчмарк ssde_x86 для сравнения производительности с HDE
  и выявления случаев, которые замедляют декодирование инструкций.

  cl 19.00.22816 (Visual C++ 2015) /O2
  win8.1 x64
  core i3 2350m @ 2.3 ГГц

  Анализ последовательности из 17 инструкций, 1M итераций

    SSDE : 4.942 с, 0.000029 с/инструкция
    HDE  : 5.542 с, 0.000032 с/инструкция

  Известны 2 случая, в которых SSDE проигрывает HDE в производительности:

    - частая реинициализация обьекта дизассемблера
    - анализ инструкций, которые требуют чтения сдвигов,
        констант, относительных адресов и т.д.

  В последующих случаях бенчмарки будут проводится на различных
  архитектурах (кроме x86, предположительно ARM LE и MIPS BE) под
  управлением ОС GNU/Linux.

3 Как использовать SSDE?

  SSDE написан на C++ с соблюдением стандарта C++11. Для подключения SSDE в
  проэкт требуеться компилятор с поддержкой C++11.

  Каждый модуль имеет хотя бы два конструктора. Основной конструктор и
  конструктор копирования. Основной конструктор принимает два аргумента:

    1: указатель на массив байт (входные данные). Конструктор не выполняет
        копирования входных данных, что требует существования данных в
        памяти, указанной указателем во время использования SSDE.

    2: IP (указатель инструкции, опционально=0). Указатель на инструкцию,
        с которой будет начато декодирование.

  Коструктор копирования может быть использован для распараллеливания
  анализа, например: при анализе ветвлений. Конструктор копирования
  копирует УКАЗАТЕЛЬ ДАННЫХ и УКАЗАТЕЛЬ ИНСТРУКЦИЙ (IP), но НЕ копирует
  информацию об инструкции.

3.1 Различные архитектуры

  Модульная структура позволяет подключить только те модули, которые нужны
  в проэкте. Ключевым файлом является "ssde.hpp". "*.cpp" файлы опциональны
  и могут быть опущены. Например: если Вы желаете использовать только SSDE
  для X86, то файлами, которые требуеться подключить в проэкт, будут
  являться только "ssde.hpp" и "ssde_x86.cpp".

3.2 Ошибки при декодировании инструкций

  При декодировании инструкций могут возникнуть ошибки. Они возникают из-за
  неверно сформировавшихся инструкций в машинном коде. В большинстве
  случаев критических ошибок НЕ возникает и декодирование инструкций
  происходит правильно даже в случае возникновения ошибки. Однако, есть
  две исключительных ошибки, при возникновении которых правильное
  декодирование инструкций невозможно гарантировать. Ими являются:
  error_opcode и error_length. error_opcode возникает в случае, если
  декодер попытался декодировать какой-либо неизвестный ему опкод, а
  error_length - в случае, если длинна инструкции превышает допустимую
  длинну инструкции. В случае если произошла error_opcode, длинна
  инструкции будет равна =1.

  При возникновении какой-либо ошибки поле "error" будет установлено в
  "true", а также поле, отвечающее за тип ошибки.


  Основными полями, сигнализирующими об ошибках являются:

    - error         : "true" в случае возникновения какой-либо ошибки
        вообще
    - error_opcode  : "true" в случае неизвестного опкода
    - error_operand : "true" в случае, если один из операндов инструкции
        не является действительным для данной инструкции
    - error_length  : "true" в случае, если длинна инструкции превышает
        допустимую (15 байт в X86)

    Кроме того, реализации для отдельных архитектур могут содержать
    поля для ошибок, специфических для данной архитектуры, например:
    "error_lock" в ssde_x86, которая сигнализирует о неверном использовании
    LOCK префикса.

3.3 Многопоточность

  SSDE не является потокобезопасным.

  Однако, многопоточный анализ для ветвлений кода может быть произведен
  используя потоки и отдельный обьект дизассемблера, созданого специально
  для определенного ответвления.

4. Добавление поддержки новой архитектуры

  Для добавления поддержки новой архитектуры, нужно создать новый класс,
  который будет окончательным (final), иметь название "ssde_АРХИТЕКТУРА",
  происходить от "ssde" и использовать конструкторы ssde::ssde. Прототипы
  всех классов должны быть описаны в ssde.hpp. Пример:

    /* ssde.hpp */
      class ssde_arm final : public ssde
      {
      public:
        using ssde::ssde;

        void next() override final;

      private:
        void reset_fields();

      public:
        bool shift_error = false; // Bit shift used wrong.
      }

  Если Вы собираетесь участвовать в разработке проэкта, стиль Вашего кода
  должен соответсвовать стилю остального кода в проэкте. Допускается
  использование исключительно английского языка в названиях переменных,
  методов, классов, структур, енумераций, типов и прочих конструкций языка,
  а также комментариев.

5. Сообщение об ошибке и контакты

  В случае обнаружения какой-либо ошибки, перед тем как писать отчет,
  удостоверьтесь в том, что Вы используете самую последнюю версию SSDE,
  а также что ошибка находится именно в алгоритме SSDE, а не в Вашем коде.
  Отправить отчет можно на github по адресу http://github.com/notnanocat/ssde/issues
  Кроме отчета, очень рекомендуется приложить код, который воспроизводит
  ошибку алгоритма SSDE. Желательно, что бы отчет был написан на английском
  языке. Отчет должен содержать информацию о том, в каких условиях
  возникает ошибка и название модуля и метода, в которых она возникает.